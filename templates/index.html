<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Monitorizare Trafic</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            /* Scoatem padding-ul pentru a centra perfect cu flex */
            color: #333;

            /* Flexbox pentru centrare verticală */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Fundal Estompat (Blurred Background) */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* În spatele conținutului */

            /* Imaginea din static/background.jpg, centrată din nou */
            background: url('/static/background.jpg') no-repeat center center fixed;
            background-size: cover;

            /* Blur fin */
            filter: blur(5px);
            /* Fără zoom suplimentar */
            transform: scale(1);
        }

        .container {
            width: 90%;
            /* Forțăm lățimea să fie mare */
            max-width: 1100px;
            /* Limită maximă crescută pentru ecrane mari */
            margin: 5px auto;
            /* Margini minime */
            padding: 10px;
            /* Padding compact */

            /* Mai transparent (0.75) */
            background-color: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(5px);
            /* Efect de sticlă opțională */

            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        h1 {
            text-align: center;
            color: #004a99;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
            font-size: 1.5em;
            /* Titlu mai mic */
            margin-top: 5px;
        }

        .chart-container {
            position: relative;
            height: 380px;
            /* Înălțime ajustată: nici prea mic (250), nici prea mare (500) */
            width: 100%;
        }

        .status {
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #555;
            font-weight: 500;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1 id="dashboard-title">Flux trafic pe {{ location_name }}</h1>

        <div style="text-align: center; margin: 5px 0;">
            <div style="background: #e3f2fd; padding: 5px 15px; border-radius: 8px; display: inline-block;">
                <h3 style="margin: 0; color: #0277bd; font-size: 1em;">Total</h3>
                <div id="total-count-display" style="font-size: 1.5em; font-weight: bold; color: #01579b;">0</div>
            </div>
        </div>

        <p class="status" id="status-text">Se încarcă datele de la server...</p>

        <div style="text-align: center; margin-bottom: 20px;">
            <label for="interval-select" style="font-weight: bold; margin-right: 10px;">Interval afișare:</label>
            <select id="interval-select" style="padding: 5px; border-radius: 5px; border: 1px solid #ccc;">
                <option value="1">1 Minut</option>
                <option value="5" selected>5 Minute</option>
                <option value="10">10 Minute</option>
                <option value="15">15 Minute</option>
                <option value="30">30 Minute</option>
            </select>
        </div>

        <div class="chart-container">
            <canvas id="trafficChart"></canvas>
        </div>
    </div>

    <script>
        // Variabilă globală pentru a stoca instanța graficului
        let myChart;
        // Variabilă pentru datele brute (cache)
        let rawData = [];

        /**
         * Funcție care grupează datele la un anumit interval de minute
         */
        function aggregateDataByInterval(data, intervalMinutes) {
            if (intervalMinutes === 1) return data; // Returnăm direct dacă e 1 minut

            const groups = {};

            data.forEach(item => {
                // Parse "HH:MM"
                const [hours, minutes] = item.timestamp.split(':').map(Number);
                const totalMinutes = hours * 60 + minutes;

                // Calculăm "găleata" (bucket) de timp
                // Ex: 14:03 (843 min) / 5 = 168.6 -> floor(168) * 5 = 840 (14:00)
                const bucketStartMinutes = Math.floor(totalMinutes / intervalMinutes) * intervalMinutes;

                // Reconvertim în "HH:MM" (Start Time)
                const hStart = Math.floor(bucketStartMinutes / 60);
                const mStart = bucketStartMinutes % 60;

                // Calculăm End Time
                const bucketEndMinutes = bucketStartMinutes + intervalMinutes;
                const hEnd = Math.floor(bucketEndMinutes / 60) % 24; // Modulo 24 pt miezul nopții
                const mEnd = bucketEndMinutes % 60;

                // Formatăm string-urile
                const startStr = `${String(hStart).padStart(2, '0')}:${String(mStart).padStart(2, '0')}`;
                const endStr = `${String(hEnd).padStart(2, '0')}:${String(mEnd).padStart(2, '0')}`;

                // Eticheta finală: "14:00 - 14:05"
                const timeLabel = `${startStr} - ${endStr}`;

                if (!groups[timeLabel]) {
                    groups[timeLabel] = 0;
                }
                groups[timeLabel] += item.count;
            });

            // Convertim obiectul înapoi în listă
            // Sortăm după ora de start pentru a le afișa cronologic (cheile obiectelor nu garantează ordinea)
            return Object.keys(groups).sort().map(time => ({
                timestamp: time,
                count: groups[time]
            }));
        }

        /**
         * Funcție principală care preia datele de la API-ul nostru
         * și actualizează graficul.
         */
        async function fetchAndRenderChart() {
            const statusElement = document.getElementById('status-text');

            try {
                // 1. Apelăm endpoint-ul GET '/api/date_trafic' definit în api_server.py
                const response = await fetch('/api/date_trafic');

                if (!response.ok) {
                    throw new Error(`Eroare HTTP: ${response.status}`);
                }

                rawData = await response.json(); // Salvăm datele brute

                // Actualizare Titlu cu Locația (dacă există)
                if (rawData.length > 0) {
                    const latestData = rawData[rawData.length - 1];
                    if (latestData.location && latestData.location !== 'N/A') {
                        document.getElementById('dashboard-title').textContent = `Flux trafic pe ${latestData.location}`;
                    }
                }

                // Configurare Timezone din backend
                const configuredTimezone = "{{ timezone }}";
                statusElement.textContent = `Date actualizate: ${new Date().toLocaleTimeString('ro-RO', { timeZone: configuredTimezone })}`;

                // 2. Aflăm intervalul selectat
                const interval = parseInt(document.getElementById('interval-select').value);

                // 3. Agregăm datele
                const processedData = aggregateDataByInterval(rawData, interval);

                const labels = processedData.map(item => item.timestamp);
                const counts = processedData.map(item => item.count);

                // --- Calculăm Totalul Cumulativ (folosind mereu datele brute) ---
                // Adunăm toate valorile din 'count'
                const totalCumulativ = rawData.reduce((partialSum, a) => partialSum + a.count, 0);
                document.getElementById('total-count-display').textContent = totalCumulativ;



                // 3. Obținem contextul elementului <canvas>
                const ctx = document.getElementById('trafficChart').getContext('2d');

                // 4. Verificăm dacă graficul există deja
                if (myChart) {
                    // Dacă da, doar actualizăm datele (evităm recrearea)
                    myChart.data.labels = labels;
                    myChart.data.datasets[0].data = counts;
                    myChart.update();
                } else {
                    // Dacă nu, creăm un grafic nou
                    myChart = new Chart(ctx, {
                        type: 'bar', // Tipul graficului: Bare
                        data: {
                            labels: labels, // Etichetele de pe axa X
                            datasets: [{
                                label: 'Număr total mașini',
                                data: counts, // Datele de pe axa Y
                                backgroundColor: 'rgba(0, 123, 255, 0.7)',
                                borderColor: 'rgba(0, 123, 255, 1)',
                                borderWidth: 1,
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Număr vehicule'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Interval orar'
                                    }
                                }
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Eroare la preluarea datelor:', error);
                statusElement.textContent = "Eroare la conexiunea cu serverul API.";
            }
        }

        // --- Execuția Scriptului ---

        // Asigurăm că scriptul rulează doar după ce pagina s-a încărcat complet
        document.addEventListener('DOMContentLoaded', () => {
            // Event Listener pentru schimbarea intervalului
            document.getElementById('interval-select').addEventListener('change', () => {
                // Dacă avem deja date, doar redesenăm cu noul interval
                if (rawData.length > 0) {
                    fetchAndRenderChart(); // Reîncărcăm (sau am putea ottimiza doar cu redraw)
                }
            });

            // 1. Preluăm datele imediat ce pagina se încarcă
            fetchAndRenderChart();

            // 2. Actualizăm automat datele la fiecare 10 secunde
            // Acest lucru este util dacă mai multe scripturi 'procesor_trafic.py'
            // rulează și trimit date în timp real.
            setInterval(fetchAndRenderChart, 10000); // 10000 ms = 10 secunde
        });
    </script>
</body>

</html>